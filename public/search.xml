<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[十一旅行中的小插曲]]></title>
    <url>%2F%E8%AE%B0%E5%8D%81%E4%B8%80%E6%97%85%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8F%92%E6%9B%B2%2F</url>
    <content type="text"><![CDATA[我人生的这一部分，叫做冒傻气。 大西北的糙人果然不适合呆在苏州上海这种湿热气候的城市。 动卧按计划1号早上出发去苏州，高铁票。 6点起床去赶9点半的高铁。但交通拥堵还是没赶上车😭 。。。无奈只能改签当晚的动车卧铺，小一千块的车费。 于是国庆第一天，在高铁站看闯关东度过😂。(这样看图有助于治疗颈椎) 第一次坐卧铺，感觉挺新奇。环境还不错。 刚开始只有我一个人，本来都快睡着了。后来上来了一对去南京的中年夫妇，然后。。。我就再也睡不着了。 记得是大妈先开始的，打呼声虽然有些大，但还能勉强眯会眼。睡在大妈上铺的大叔表示不服，亲自示范给我们啥叫震耳欲聋，振聋发聩🙉 大妈不打呼了，因为她也被吵醒了，整个房间瞬间变成了大叔的主场。。。 睡在我上铺的兄弟也睡不着了，穿上外套出去了，我知道，他一定是想去静静。也或许他是想出去问问，能不能把之前另一个女生跟他交换的铺位换回来😆 我觉得自己有义务提醒大叔控制下自己，于是起身敲大叔的床板，没醒。求救的眼神投向大妈，大妈顿时会意也起身，敲床板。大叔醒了。但显然大叔还没有完全清醒，嘟囔了两句家乡话。两人交谈了几句，大叔转身又睡了。 声音虽然小了下来，但我知道，这只是暴风雨前的宁静。睡在我上铺的兄弟回来了，不知他是否意识到房间里的声音小了很多😌。 果然，不一会，打鼾声又开始了。不幸的是，我没有赶在这之前睡着。 南京站到了，大叔大妈终于下车了。但这时离苏州也只有不到一小时的车程，看来睡觉是不可能了。天将降大任于斯人也，必将苦其心志。苦就苦吧😖。 5点20分，苏州到了，我也下车了。 看电影拙政园商务座找酒店坐班车 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>苏州</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java判断素数]]></title>
    <url>%2Fjava%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[嗯，就是来秀插件的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>判断素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未来是星辰大海_Part2]]></title>
    <url>%2F%E6%9C%AA%E6%9D%A5%E6%98%AF%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7-Part2%2F</url>
    <content type="text"><![CDATA[记录一下博主小半年的心路历程。 Part1 尘埃落定(2017.10-2017.11)自从去年9月份拿到第一个offer后，就直接签了，后来也没有再找过。当时的想法是找到一个还不错的就行，毕竟事少离家近嘛。于是安排好自己毕业前的计划，开始了在宿舍颓废的生活，期间将自己的游戏账号打到了钻石，吃饭靠舍友投喂。。 两个月后，按照计划，我怀着紧张中带着一丝小激动的心情出发去公司实习。 Part2 心态有点崩(2017.12-2018.02)emmm…刚开始实习的时候，也没啥感觉。毕竟需要学习的东西有很多，每天下来也能收获不少东西。 但是时间长了，问题就开始出现了。 无脑病态的加班、毫无技术难度可言的工作、传话筒一般的工作感受让我觉得有些幻灭。 其实对于软件测试这个岗位呢，我也知道刚开始一般都是功能（黑盒）测试，比较基础。我也是愿意从基础打起的。但我想学习更多的测试技术，利用一些工具来提高工作效率。这样能提高自己以后的竞争力和学习能力。但这些，在我两个多月的实习工作中，没有感受到。 此外，繁琐的管理制度和考核流程也在考验我的耐性。这样的工作环境无法达到我“还不错”的标准，如果长期这样下去，我可能连Hello World都不会写了。无脑病态的加班更是占用了我的个人时间，基本上失去了利用空闲时间提升自己的可能性。 总的来说，这绝对不是我要的生活，我需要重新开始找工作（论早点实习的重要性）。 Part3 重新开始(2018.03)过年那会，我就开始寻找目标。经过实习之后，我更加明确自己想要什么，完善了自己的简历。所以很快就确定了目标。 开学之后，我参加了宣讲会。提问环节HR说测试这个岗位在我所在的城市只招5个人。这意味着我要跟好多985/211的学生甚至研究生竞争，作为一个普通一本的本科生，在学历上，我可以说是毫无胜算。 不过我还是想尽力一试，毕竟这是我还有应届生光环的最后一次找工作机会。而且他们公司的工作理念很吸引我，岗位需求描述也和我很贴合，我确实很想成为他们的一员。 笔试 宣讲之后的几天，他们公司提供了线上笔试题（全英文），我有4天时间去完成。处理完学校的杂事（学校真是一个让人又爱又恨的地方），我在图书馆泡了两天做完了笔试题（答案也是全英文），半张纸的题目我写了10张纸的答案。 之后开始了几天的等待期，等待的过程是煎熬的。就在我怀疑自己要挂了的时候（是不是嫌弃我答案太长了/上传答案的时候我没有改文件名等等猜测），HR给我打了电话，让我去参加面试。感觉整个世界都晴朗了。 面试 在经过了精心的打扮（两天没洗头），一路畅通无阻（坐反了公交车到终点站才发现，最后叫了辆滴滴），心情舒畅（电梯里跟他们公司的外国小哥哥用英语尬聊了一分钟）之后，我到达了面试地点。没有我想象中的人山人海，因为那天只面试3个人。 由于我非常缺乏面试经验（秋招只面试了一家拿到offer就签了，这是人生中第二次面试），所以对我而言面试的过程是漫长的，还是紧张的（两个面试官，一男一女）。坐在大会议室的我有一种任人宰割的感觉。。，在面试官的调节下（面试官很友好的），我渐渐没了紧张的感觉。在后边的面试中，做到了知无不言，言无不尽。还跟面试官聊起了人生和理想。整体感觉挺High的。就这样，原本只给我40分钟的面试时间，愣是聊了一个多小时。最后由于别人要在会议室开会，我们还是结束了面试。 offer 在经过1天的等待后，HR给我发了口头offer，之后几天再去公司签了正式offer。 没错，这家公司就是传说中的TW(ThoughtWorks)。 Part4 最后的规划(2018.04-2018.06)今天已经4月9号了，离毕业论文答辩还有两个月的时间。这两个月我需要闭关修炼，完成3件大事： 做毕设 完成TW毕业生入职前的线上培训学习并完成所有任务卡（所以后边也会发表一些技术相关的学习总结博客） 拿到驾照 emmm…有点理想主义，毕竟只有两个月，不过时间是挤出来的嘛，祝我好运。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>人生规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20岁光阴不再来]]></title>
    <url>%2F20%E5%B2%81%E5%85%89%E9%98%B4%E4%B8%8D%E5%86%8D%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[时间啊，你慢点走。 这个TED演讲是博主几年前看过的，留下了很深的印象。今天又重温了一遍，感触更深了。所以推荐给大家，TED名字叫做”20岁光阴不再来“，亲们也可以在网易公开课里看到。 我的观后感在这个TED中，演讲者给出了一些对20多岁年轻人的忠告和建议，可以概括为以下几点： 忠告 30岁不是新的20岁，所以不要挥霍你时间，而是应该用这些时间去做一些有意义的事。年长者总会对20岁的年轻人说“你们还年轻，未来会有的”，实际上这不是一种激励，而是麻痹了年轻人的奋斗激情，助长他们的拖延症。如果我们真的听从了这些年长者的话，30岁才开始建立事业、家庭，可那个时候你又凭什么做到这些呢？ 不要坐井观天，不要做无谓的探索，因为更多的时候你不是在探索未来，你只是想拖延。 不要等到该结婚的年龄才随便找个人建立婚姻关系。就像演讲者说的：20岁时谈恋爱就像玩抢椅子，每个人都东奔西跑的玩乐，但是在30岁左右时音乐停止了。每个人都开始坐下，我不想只有我站着，所以我才想嫁给我的丈夫，因为他是我30岁时离我最近的椅子。 建议 对自己进行投资，投资的目标是成为你想成为的人。包括未来工作所需和生活精神需要。比如健身、读书、学习专业知识等等。 学会利用身边的弱关系，扩大交际范围，而不是只跟与自己年岁、思维方式相差不多的人交往。比如演讲者提到了一个患者通过室友的表亲找到了心仪的工作。 从现在开始选择自己的家人，你以后想跟谁生活在一起，想拥有什么样的婚姻。而不是等到30岁才思考这个问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>TED</tag>
        <tag>告别拖延</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试矩阵]]></title>
    <url>%2F%E6%B5%8B%E8%AF%95%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[谈谈对各种测试方法做二维定位后形成的测试矩阵. 最近在ThoughtWorks的#TW洞见#栏目看到了测试矩阵的概念和介绍，觉得很有意思。也让我在另一种层面上理解了各种测试方法。 你晕了没相信大家在初学测试的时候一定听过下列测试名词：单元测试、集成测试、性能测试、API测试、UI测试、压力测试、冒烟测试等等。诸如此类，不胜枚举。这么多的“测试”不知道你晕了没，反正博主开始是挺晕的。 此外，不同的人对这些测试的理解也不尽相同，比如“单元测试”，在Java中，有人说一个类就是一个单元，有人说一个方法就是一个单元，甚至有人说一个完整的API就是一个单元。一千个人眼里有一千种单元测试。。。 测试矩阵 既然有这么多的测试方法，在实际的测试工作中，我们到底怎么测试呢。像上边说的，测试种类如此繁多，难于理解，所以在测试时也难以沟通。 其实，我们可以从两个维度来理解这些测试方法，并将其应用到实际工作中。 其中，第一个维度就是测试实现的层次和粒度，说白了就是测哪。是方法，类，还是API？是应用、系统、还是整个平台？ 而我们常说的性能测试，功能测试，安全测试等等，都可以归为第二个维度，即测试的目标，也就是测什么，咋测。 这两个维度结合起来就形成了下边的测试矩阵： 测哪\咋测 功能测试 集成测试 性能测试 安全测试 端到端 test test test test API test test test test 类 test test test test 方法 test test test test 有了这样的认识，以后进行测试工作时工作起来就方便多了。我们可以进行“方法级别的功能测试”、“API级别的性能测试”等等。这样，使测试内容变得更加清晰。 事实上，在实际测试工作中，大多数情况下都进行的是功能测试，而常常忽略了第二个维度，即咋测。所以，根据测试矩阵进行测试，可以避免这种问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发与测试]]></title>
    <url>%2F%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%8E%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[啥是敏捷，敏捷是啥？ 先来首Music: 与“敏捷开发”的初次接触开始接触到“敏捷”这个概念，是在公司实习的时候，因为所在项目组实行的是敏捷开发。后来又读了几本关于敏捷测试的书籍（软件测试的艺术第三版—Chapter9），有了更深入的理解。所以本文主要是博主的实习经历总结和读书笔记。 接下来我将从3个方面：What?（什么是敏捷开发）&Why（为什么要实行敏捷开发）&How（如何实施）来谈谈我对敏捷软件开发模式的理解。 What?敏捷开发简单来说，敏捷开发是一个以用户为中心、客户需求为导向的开发过程。强调客户合作、响应需求变化。是一种迭代式、增量式的开发模式。主要有以下特点： 依赖客户参与 测试驱动开发（TDD） 开发周期短 敏捷测试对应敏捷开发模式，敏捷测试要求每个人都参与到测试过程中，所以需要团队人员之间进行大量的沟通与协作。 客户：定义用例和程序属性参与验收测试 开发和测试：共同打造可以进行功能自动化的测试配件 与传统测试过程相比，敏捷测试主要有以下特征： 测试并不是一个独立的阶段，而是和开发过程紧密联系并驱动开发（TDD）。 开发者先创建单元测试用例（失败验证测试），然后实现软件单元代码。 敏捷测试依赖于自动化测试。 测试者要通过持续的测试反馈推动项目前行，并帮助开发者修复bug。 Why? 与传统软件开发模式相比，敏捷开发把客户的参与作为关键环节。这样引入了灵活性，提高客户满意度。 如今的客户总是需要能立即发布的高质量应用产品，使得传统开发模式不能适应这种激烈的市场竞争环境。所以大多数企业更青睐像敏捷开发一般，轻量化、快速的开发方法。 How?事实上，敏捷开发方法有很多种，比如：功能驱动开发（FDD）、开放统一过程等等。但最流行的是极限编程（XP）开发方法和Scrum（进度跟踪）项目管理方法。 XP是一种迭代式、增量式的开发模式，非常强调单元测试和验收测试，是现在最著名的敏捷方法。Scrum是一种迭代式、增量式的项目管理方法，适用于所有的敏捷方法，用来度量开发速度和进度。两者相辅相成，形成了现今最流行的敏捷开发模式。 XP编程面向对象的编程语言如Java/C#，都含有全功能的API，所以可以利用其迅速实现大型复杂应用。但正因如此，应用程序的质量经常得不到保证。 XP编程的目的就是短时间开发高质量的应用程序。所以，XP方法将主要精力集中在测试上，在产品设计阶段之后，必须首先生成单元测试用例，然后才编写代码通过测试。 XP开发模型用12个核心实践来驱动该过程： NO.1：需求分析（开发、客户、产品均参与） NO.2：小规模、递增发布（增加实在/可增值的新功能，频繁发布新版本） NO.3：系统隐喻（编程小组确认开发规则） NO.4：简要设计（实现简要设计，通过单元测试，不需重复设计，只要不停实现） NO.5：连续测试（编写模块之前先生成单元测试用例，模块在通过单元测试后才算完成，程序在通过所有单元测试和验收测试后才算结束） NO.6：重构（清理调整代码库，任何重构之后需重新进行所有单元测试） NO.7：结对编程（两位程序员在同一台机器协同开发代码库，便于对代码实时检查，提高缺陷发生纠正率） NO.8：代码的集体所有权（所有代码归全体程序员所有，不存在某一个程序员只开发某一个代码库） NO.9：持续集成（变更后的代码在通过单元测试之后将其集成到代码库中） NO.10：每周工作40小时（不允许加班，如果每周都全力工作了40个小时，就不需要加班，在版本发布的前一周例外） NO.11：客户在现场（编程小组可以随时与客户沟通） NO.12：按标准编码（所有的代码需要满足编程小组设计的系统隐喻） XP测试 为满足XP方法的流程和思想，XP测试强调连续测试。主要由两种类型的测试组成：单元测试和验收测试。 XP单元测试单元测试是XP测试采用的主要测试方法，具有两条规则： 1.所有的代码模块在编码开始前必须设计好单元测试用例（最主要的优点在于可以更好理解程序需求，排除混淆） 2.产品发布之前所有的代码模块必须通过单元测试 为了迎合项目进度，单元测试通常要用自动化测试套件来减轻单元测试负担，测试套件可以生成测试报告并对程序中出现的缺陷进行分类，帮助修复bug。 XP验收测试 验收测试是判断应用程序是否满足功能性和易用性及其他需求，在设计阶段，开发人员和客户设计验收测试，由客户执行。 验收测试需注意以下几点： 同单元测试一样，验收测试也可是自动化的。测试内容为计算/数据等，可用自动化测试；当测试内容为界面布局和颜色等，测试应该是非自动化的。 与单元测试相同，验收测试过程中发现多个bug时，应对其进行优先级排序，每次bug修正后都要重新执行验收测试。所以验收测试也算是一种回归测试。 一个完整XP项目的运作流程下表给出了一个完整XP项目应进行的流程： 步骤 内容 Step1 程序员与客户进行产品需求分析会议，决定产品使用场景 Step2 编程小组进行内部会议，将需求分解为独立的任务，并估计每个任务所需要的时间（StoryPoint） Step3 程序员向客户提交任务清单，并要求客户对任务清单进行优先级排序 Step4 编程小组根据程序员具备的能力，将任务分配给对应结对程序员 Step5 每对程序员按照程序需求和规格说明，编写相应任务的单元测试用例 Step6 每对程序员编写完成通过其单元测试用例的任务代码，期间不断对代码进行修改和重测，并对代码库进行整合和集成 Step7 编程小组发布应用程序的一个预览版本，由客户进行验收测试，并通过修改缺陷不断进行回归测试 Step8 程序员在验收测试成功的基础上发布产品版本 其他工作：程序员根据最新经验更新对客户需求的时间估计方式。 ##敏捷开发学习网站## Scrum中文网Scrum指南 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习小记</category>
      </categories>
      <tags>
        <tag>敏捷测试</tag>
        <tag>极限编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类中的代码块执行顺序]]></title>
    <url>%2Fjava%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[代码实例分析java类中的代码块执行顺序. 一道笔试题下面是一道阿里的java校招笔试题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class HelloA{ //构造方法 public HelloA() { System.out.println("父类构造方法"); } //非静态代码块 { System.out.println("父类非静态代码块"); } //静态代码块 static{ System.out.println("父类静态代码块"); }}class HelloB extends HelloA{ //构造方法 public HelloB() { System.out.println("子类构造方法"); } //非静态代码块 { System.out.println("子类非静态代码块"); } //静态代码块 static{ System.out.println("子类静态代码块"); } }public class Test{ public static void main(String[] args) { new HelloB(); new HelloB(); }} 请写出上述代码的输出，看完本文你就会有答案。 代码块分类及其执行顺序代码块分类代码块，就是使用”{}”定义的一段代码，根据代码块定义的位置和关键字，可分为以下四种： 普通代码块：定义在类的方法中的代码块。 构造块：定义在类中的代码块（无修饰符）。 静态代码块：使用static修饰的，在类中定义的代码块。 同步代码块（与多线程有关，本文不涉及） 执行顺序（无继承）看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person{ public Person() { System.out.println("非主类构造方法"); } { System.out.println("非主类构造块,优于构造方法执行"); } static { System.out.println("非主类静态块，优于构造块执行，无论产生多少实例化对象，只执行一次。"); } }public class Hello{ public Hello() { System.out.println("主类构造方法"); } public static void main(String[] args) { System.out.println("----start----"); new Hello(); new Person(); new Person(); new Hello(); System.out.println("-----end-----"); } { System.out.println("主类构造块"); } static{ System.out.println("主类静态块，优于主方法执行"); }} 执行结果： 结论： 其中： 主类静态块优于主方法执行。 无论生成多少类对象，静态块只执行一次。 主类和非主类的构造方法、构造块谁先执行取决于代码顺序，与主类/非主类无关。 执行顺序（有继承）我们知道，在继承的情况下，子类在实例化时，首先调用父类的构造方法，然后再调用子类的构造方法。因此，结合上面的结论，我们就可以得出开始那道笔试题的结果。 为了方便观察，对代码改动如下： 1234567891011public class Test{ public static void main(String[] args) { System.out.println("----start----"); System.out.println("---first---"); new HelloB();//first System.out.println("---second---"); new HelloB();//second System.out.println("-----end-----"); }} 答案在这里： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>javaEE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未来是星辰大海]]></title>
    <url>%2F%E6%9C%AA%E6%9D%A5%E6%98%AF%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7%2F</url>
    <content type="text"><![CDATA[今天去签了三方，所以，我的大学生活也许真的要结束了。 大学三年以前常听别人说，大学其实只有短短三年。开始我是不信的，现在却不得不信了。 大四安排大四刚开始，金九银十。秋招开始了： 大佬：一个offer接一个offer，择优录取 我：找了一个offer，得，还不错，签了吧 没错，作为第一次面试就拿到了offer，还签了三方的我。确实是一个很容易满足的人，当然，这跟实力也有关系，我等渣滓不敢跟大佬比。。。 其实offer拿到有段时间了，到今天才去签。（中间那段时间把段位从黄金升到了铂金，再也没人说我是黄金狗了），当然，还干了点别的事情。 唉，本来想深沉一下，咋越写越欢脱。。。 后边的安排可能就是先把照学到手，不过最近改革了，估计很难成为老司机的一员了。然后去实习，春节前刚好结束（说不定还能参加下公司年会）。 学期末确定下毕设题目，然后开整。解决完了去旅个游，毕竟大学生优惠什么的不能浪费。。。 然后毕业照走一波，之后再去公司报到，咱也是社会人了。 三年回首这个只能在心里默默吐槽了，不过怎么说呢，有句话是成长的过程就是越来越觉得以前的自己是个xx的过程。 嗯，我想了一想，说的还真对。 那些让我后悔的事 说实话，还真没啥。 说自己没好好学习吧，那是我懒我认了。不过咱好歹还拿过奖学金不是~ 说自己没挂过科把，谁说的，挂过一门。。。（说起来既拿过奖学金，又挂过科的，估计我也是独一份） 说没谈过恋爱吧，有那个时间我还不如去睡觉，省事省心还自由不是~ 其实吧，哪有那么多后悔的事情。 人嘛，该干嘛的时候就得干嘛，每个时间段都有自己该做的事情。做完了你才有资格搞其它有的没的。结果是你自己没做，后来又说后悔，你说这不是耍流氓这是啥？ 或许你觉得当时没有做好，但人的身心发展都是分阶段的，几年之后再回想之前做的事情，肯定觉得不对味呀。人要是一直钻这个牛角尖，那就没啥意思了。 对未来的一点小小畅想梦想还是要有的，万一实现了呢。 想要坚持的 健身（身体最重要） 读书（腹有诗书气自华（老脸一红）） 学习（行业特殊，为了不被淘汰掉，坚持学习真的很重要） 坚持给父母的全民K歌账号打call（真的超爱唱歌） 除了最后一条，我还真不敢保证每天都做，毕竟谁都不是圣人。但是要尽量坚持下去。 想要实现的等我有钱了，要啥啥没有？┑(￣Д ￣)┍ 其它有的没的都在心里。 好了，也该收收心了。看这个日子，上次发文都在一月前了。之后得给自己博客上点干货了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>未来</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[对近几天的Git学习做一个小结。 学完了廖雪峰的git教程，对git的概念和基本操作有了更深的理解。对“版本控制”的概念也理解的更加深刻。 几点感受以下是我学习了git之后的一些感受： 成为了Linus Benedict Torvalds的一枚小迷妹（以前也是，现在妥妥的）。 世上没有后悔药？不存在的，git的版本回退完美的实现了这一点。 搞清楚了git和github的关系，后者只是拥有一个git远程仓库，可以通过git连接并实现相应操作。 Git服务器可以轻松搭建，除了github，还有coding/gitee等网站提供git服务。 工作效率真的提升很快。。。 干货下面对学习中涉及到的git命令做分类总结，都是最常用的。 git本地管理 git最基本的一些操作 git init：将某目录变成git可以管理的仓库（添加.git目录） git commit -m “…”:一次性提交多个文件（add进来的文件） git add xxx.md:可以多次添加多个不同文件 git status:可以时刻掌握仓库当前的状态 git diff:显示具体修改的内容（与提交进去的文件相比） git log：显示从最近到最远的提交日志，加上–pretty=oneline参数可以将每次提交信息压缩成一行,最前边的数字加字母是指每次commit的commit-id,是16进制的表示形式 .gitignore文件：包括git需要忽略提交的文件名，此文件也需要提交到git 版本回退 世界上是有后悔药的 git reset –hard HEAD^:回退到上个版本（上上个版本HEAD^^,上100个版本是HEAD~100。HEAD是指向当前版本的指针，因此可以通过调整HEAD来在历史版本间穿梭） git reset –hard commmitid：在没有关闭上次回退时的命令窗口时，可以取消回退。commitid没必要写全，git可以自己去找 git reflog:可以显示每一次commit和回退的id号，如果命令窗口关闭，可以用此命令先找到commitid，然后用上个命令取消回退 git checkout – file：撤销在工作区对file做的修改，包括撤销对file文件的删除 git reset HEAD file & git checkout – file：对file的修改已被add到stage，用前者删除add到stage的修改，再用后者撤销工作区的修改 git reset –hard HEAD^ :已经将想撤销的修改添加到了版本库，但还未提交到远程库。用版本回退撤销修改 git rm file&git commit -m “delete file”：删除已添加到版本库的文件 git checkout:用版本库里的文件版本替换工作区的文件版本（一键还原） 远程库连接 连接远程库，进一步实现团队协作。 git remote:查看远程库信息，详细信息加上-v选项 git remote add origin git@github.com:Summyj/xxx.git：将本地git仓库与github远程库想关联,也可以是其它库，远程库默认名字是origin，也可以设为其它，比如github git push -u origin xxx:把本地仓库指定分支·内容推送到远程，下次推送可以不用-u参数因为第一次推送master分支时如果加上-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，所以在以后的推送或者拉取时就可以简化命令。 git clone git@github.com:xxx/xxx.git:从远程仓库克隆到本地，后边是地址 git remotr rm origin:删除本地库关联的origin远程库 分支创建管理 实现更安全便捷的版本控制。 git checkout -b xxx:git check命令加上-b参数表示创建并切换到xxx分支，此命令相当于两条命令： git branch xxx git checkout xxx git branch:查看当前分支（列出所有分支，当前分支前边会标有*号） git merge xxx:将指定分支xxx合并到当前分支,首先要切换到当前分支（不一定是master分支） git branch -d xxx:删除某分支（合并后再删除） git branch -D xxx:强行删除某个没有被合并的分支 git log –graph –pretty=oneline –abbrev-commit：用分支图展示各分支合并情况（或者直接git log –graph，但这将会显示所有历史合并图） git merge –no-ff -m “…” xxx:禁用git合并时默认的fast-forward模式，生成新的commit加入分支信息。-m后的内容就是合并信息 工作现场存储 版本控制的freestyle. git stash:将当前工作现场储藏起来，等以后恢复现场后继续工作 git stash list:查看储藏的工作现场 git stash apply:回复储藏的工作现场 git stash apply stash@{x}有多个stash时恢复指定的stash git stash drop:恢复现场并删除stash list的内容，如果有多个stash,默认恢复的是最新的stash. 多人协作 小伙伴们的友情 git checkout -b xxx origin/xxx:刚从远程库克隆到本地时只有master分支，用此命令创建和远程分支对应的分支 git pull:多人协作时，远程分支比本地分支更新导致推送失败，用此命令从远程库抓取该分支最新的提交并和本地分支进行合并，合并有冲突需要手动解决 git branch –set-upstream xxx origin/xxx:git pull失败时需要创建本地分支和远程分支的关联 标签管理 更方便进行版本控制，与commit id相比更好记。相当于版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针。与HEAD指针相比，后者可以移动，但标签不能移动），所以，创建和删除标签都是瞬间完成的。 git tag xxx:打标签 git tag v0.3 646123:将commit id为646123的提交打上v0.3标签。这样可以解决忘记打标签的问题 git tag:查看所有标签（按字母排序，而并非时间） git show tagname:查看标签信息（包括说明文字） git tag -a v0.x -m “…” 615465:创建带有说明的标签，用-a指定标签名，-m指定说明文字 git tag -d xxx:删除指定标签（因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。） git push origin tagname:推送标签到远程 git push origin –tags:一次性推送全部尚未推送到远程的本地标签 git tag -d tagname & git push origin :refs/tags/tagname:删除已推送到远程库的标签，先从本地删除，再从远程删除 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习小记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归求解1到100求和]]></title>
    <url>%2F%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A31%E5%88%B0100%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[递归求解1到100的和是一个常见面试题。 思想： 思考一下，从1加到100可以分解成： 1+（2加到100的和） 1+2+（3加到100的和） 1+2+3+（4加到100的和） …… 怎么样，这样是不是有点递归的味道了？递归的出口就是1。 所以，可以编写如下代码： 代码： 123456789int count(int n){ if (n > 1) { return n + count(n - 1); } else return 1;} 这样，不仅可以求1到100的和，还可以求任意区间数字的和。只要改变递归出口和上限即可。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>笔试面试题</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于闰年，你不知道的那些事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E9%97%B0%E5%B9%B4%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[“四年一闰，百年不闰，四百年再闰”。你知道为什么吗？ 判断某一年是否是闰年几乎是所有编程语言的基础练习题之一，而我们必然也熟知其规则： 整除但4不能整除100 整除100又能整除400 这就是俗语中的“四年一闰，百年不闰，四百年再润”，我们当然可以根据这个规则编写程序判断闰年，但你知道为什么这样规定闰年的算法么？ 事实上，闰年是为了弥补因人为历法规定，造成的年度天数与地球实际公转周期的时间差而设立的。所以闰年有366天。 那么具体是怎么弥补的呢？ 我们知道，平年一年只有365天，而实际上地球绕太阳的公转周期为365天5小时48分46秒。即一回归年。所以公历的每一年都比回归年短0.2422天，四年累计起来，共短0.9688天。 大概就是一天，所以为了弥补这一天的时间差。给2月加上1天，就有了闰年。这样一来，每四年里就有一个闰年，3个平年。这就是四年一闰。 那么百年不闰，四百年再闰又是怎么回事呢？ 是这样的，刚才说四年累计起来的时间差只有0.9688天，这比我们给闰年增加的一天还少0.0312天，所以每四年就会多出0.0312天。这样400年后，就会比实际天数多出3.12天。所以我们必须在这400年中少设3个闰年。这样公历年的平均长度与回归年就近似了。 那这3个闰年怎么少呢？ 很简单，给百年除以400即可，比如2000-2400这400年： 2000/400=5 2100/400=5.25 2200/400=5.5 2300/400=5.75 2400/400=6 可以发现，正好有3个不能整除的整百年。所以规定年份是整百数的必须是400的倍数才是闰年。这就是百年不闰，四百年才闰的规定。 你明白了吗？ 当然，根据规则，我们就可以编写代码判断了： 1234567891011121314151617181920212223242526int main(){ int year; cin >> year; if (year % 4 == 0) { if (year % 100 != 0)//1. 能整除4，不能整除100 { cout <]]></content>
      <categories>
        <category>C/C++基础</category>
      </categories>
      <tags>
        <tag>闰年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱你就像爱生命]]></title>
    <url>%2F%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD%2F</url>
    <content type="text"><![CDATA[你要是愿意，我就永远爱你，你要是不愿意，我就永远相思。 王小波一直是我喜欢的作家之一，更令人惊讶的是，他竟然还是个程序员。 虽然他的作品部部经典，引人深思。但这一篇写给他妻子李银河的情书，却能真正打进人的内心。每看一遍都回味无穷，这是一篇极美的文章，堪称史上写的最好的情书，原来世间仍有这么好的爱。 你要是喜欢了别人我会哭，但是还是喜欢你。 你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。 我是爱你的，看见就爱上了，我爱你爱到不自私的地步，就像一个人手里一只鸽子飞走了，他从心里祝福那只鸽子的飞翔。你也飞吧，我会难过，也会高兴，到底会怎么样我也不知道。 不管我本人多么平庸，我总觉得我对你的爱很美。 我现在已经养成了一种习惯，就是每天要对你说几句不想对别人说的话。 有时候你难过了，这个时候我更爱你，只要你不拒绝我我就拥抱你，我会告诉你这是因为什么，就是我不知道是为了什么。 我爱你，这是我的命运。 我决不为了仪式爱你，我是正经爱你呢。我一正经起来，就觉得自己不坏，生活也真不坏。真的，也许不坏？我觉得信心就在这里。 但愿我和你，是一支唱不完的歌。 我真的是个好人，我对好多人怀有最深的感情，尤其是对你。我很想为别人做好事，尤其是对你，我真想把我做出的一切好事全献给你了。 我们是两个在宇宙里游荡的灵魂，我们不愿孤独，走到一起来，别人与我们无关。我把我的整个灵魂给你，连同它的怪癖耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。 只希望你和我好，互不猜忌，也互不称誉，安如平日，你和我说话像对自己说话一样，我和你说话也像对自己说话一样。 说吧，和我好吗？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>美文</category>
      </categories>
      <tags>
        <tag>王小波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建折腾记]]></title>
    <url>%2FHexo-GithubPages-CodingPages%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建博客的正确姿势。 前言博客初识开始写博客只是用CSDN发布，本来开开心心。 然而有一天，我的一篇博客被系统直接删掉了，原因是含有敏感词汇。联系了管理员之后才恢复😐。 又想起之前一天发了好几篇，被系统禁发了。 有点小生气，发个博客也这么麻烦。索性就自己搭一个好了，然后就开始了折腾之旅。 或许你不相信，但我确实见过有许多非互联网行业的人也搭建了自己的博客。所以在搭建博客这件事上，确实没有专业之分。 说白了，搭建博客就是用一堆别人的东西，来做一个我们自己的东西。Hexo、主题、GithubPages、CodingPages，这些没一样是你的。而且这些都是免费的，除了买域名要花一只棒棒糖的钱（我搭建博客一共就花了3块钱😂） 所以，人家设计的东西，只要拿来用就可以了。 背景知识 Github：建立一个github.io的库，没有账号的话可以注册一个。 Hexo：需要下载它的安装包和主题，你只需要知道一些部署博客的命令（不超过5条）。这些命令也可以不会，因为文档里都有。 GithubPages：是Github推出的功能，只要建立了github.io库，就默认在使用。它相当于一个服务器，可以保存所有博客文件，是电脑上博客站点的一份备份/ CodingPages：跟GithubPages作用相同，但这个是国内的。为了双重保障和你的博客运行速度。建立还是设置下它。 所以，搭建博客时可以什么都不懂。但为了以后能更好的操作博客，建议在搭建成功之后，好好学习一下Github的使用。网上的教程也有很多，这里就不再赘述。 虽然我们可以什么都不懂，但以下3样东西必须要有： 耐心：搭建博客是一件非常折腾的事情，所以耐心很重要 细心：一定要细心，确保每一步都是正确的。 一定的学习能力和钻研精神，遇到困难一定要面对它，主动解决。 为什么搭建博客？这个问题相信你已经有了自己的答案，但我还是建议你看看这2篇文章： 我为什么坚持写博客？ 为什么你要写博客？ 搭建博客需要多长时间？这个因人而异，在我看来，有这么几种： 半天：只是搭建，不涉及到换域名和个性化，并且了解背景知识。那么只要半天便可以搭建完成 一天：需要了解背景知识，并且换了域名和主题，但没有太多的个性化 两天：设置了评论，字数统计等各种个性化设置（比如我） 三天甚至更多：各种找个性化插件和设置，一直在折腾的人 当然，前两种都是你没有遇到太大的坑或者困难所给出的估计时间。如果你在搭建的时候碰到了很多的问题，那么这个时间就得延长了。因为这种问题一般不好查。 背景知识搭建博客之前，你应该知道自己在做的是什么。先把事情做对，再把事情做好。所以你需要了解一些背景知识。 建立博客的渠道 通常来说，建立博客的通常渠道包括以下3种： 在博客平台上注册，比如 博客园、CSDN、新浪博客 等。 利用博客框架搭建，如 WordPress、Jekyll、hexo 等。 自己用代码写一个。 其中，第一种最简单，也最受限，说不定还会被删帖删号（我就遇到过这种情况）。第二种稍复杂，另外需要自己找部署的服务器，但可定制化较高，是很多人的选择。最后一种，是在重复造轮子，不过从另一个方面来看，倒是锻炼编程能力的好方式。 而我们要做的，就是第二种：既不受限，难度也不大。 为什么选择GithubPages和Hexo用第二种方式搭建博客也有很多方法，但主流的有两种： Wordpress GitHub Pages+Hexo 很多人用 Wordpress，为什么我要用 GitHub Pages 来搭建？ 开始我也不知道用哪个，但在网上搜了教程后，发现wordpress比Hexo要麻烦很多。 Hexo是开源在Github上的，而且轻快便捷 GitHub Pages 有 300M 免费空间，资料自己管理，保存可靠。 学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多 顺便看看 GitHub 工作原理，最好的团队协作流程 GitHub 是趋势 概念介绍HEXOHexo 是一个简单、快速、强大的静态博客框架，基于Node.js。由台湾大学生tommy351创建。并把它开源到了Github上，这里是它在Github上的地址：HexoGithub，它主要有以下优点： 极速生成静态页面 一键部署博客 丰富的插件支持 支持 Markdown 更多内容可以查看Hexo的官方文档，建议你只看看介绍部分，其它的你现在也看不太懂。等你搭建好了博客再去详细了解其他的内容就会轻松很多：Hexdocs GitHubGitHub是一个代码托管网站和社交编程网站。这里聚集了世界上各路技术牛叉的大牛，和最优秀的代码库。是全球程序员的天堂。因为是国外的，所以界面全是英文。博主英语过了六级刚开始接触的时候心都突突，不过不要怕，不是还有翻译么， 也有好多人调侃它是全球同性交友平台，其实我不太懂这个梗（女程序员也是很多的好么） GitHub PagesGitHub Pages是用来托管 GitHub 上静态网页的免费站点，其他的不多说。 CodingPages和GithubPages功能相同，其对应的Coding平台也可以实现和Github相似的功能。但没有后者那么出名。是香港的公司，也算是国内的。 看了这些，我相信你一定还是一脸懵逼的。但你可以简单理解成下边的的一段话： 利用Hexo和GithubPages/CodingPages搭建博客，实际上就是利用Hexo在本地（你的电脑上）生成一个博客站点，然后利用网络将它传输到Github/Coding上进行拷贝和备份。再由Github和Coding提供的GithubPages/CodingPages服务将博客部署到网上，这样你的博客就可以作为一个独立的站点被别人浏览（正式上线）。同时你也可以在Github和Coding上管理你的博客。 如果你还想了解更多背景知识，可以看看这篇文章：搭建个人博客，你需要知道这些 搭建过程搭建步骤一般来说，搭建博客有以下几个步骤： 获得个人网站域名 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 推送网站 绑定域名 在Coding上部署你的网站 其中，1.7.8你可以不做。但剩下的必须要做，一步都不能少，也不能错。在你看下边推荐的博客的时候，不要忘记看看我下边的建议。 1-7步请看：这篇博客不只前7步，如果你做完了就可以往下做，因为后边的都是属于个性化部分，所以博主在这里没有显示。GitHub+Hexo 搭建个人网站详细教程 第8步请看：这篇博客是在你做完了前7步的基础上做的。hexo干货系列：（四）将hexo博客同时托管到github和coding，这篇博客也讲了怎么在CodingPages部署，可以和上一篇对照着看：我的Hexo博客站的创建历程(一)【Github&Coding双管齐下部署Hexo】 我的建议和踩过的坑 第一篇： 域名建议买.top，比较便宜。当然，土豪随意。 下载Node.js或Git时，由于众所周知的原因，下载速度会很慢。这时你需要看Hexo的官方文档，上边给出了离线下载的地址：Hexdocs 在安装Hexo这一步，hexo init blog及其之后的命令都是在Blog/blog这个目录下进行的，一定要注意，不能弄错了。博主刚开始就是搞错了路径，结果一直报错。。。 如果你在安装Hexo或者之前的步骤中有报错，建议你重新下载安装。因为这之前的过程全是安装的部分，一旦出错，没有别的原因，一定是你的操作有问题。而且你解决错误的时间一定要比重新安装耗费的时间长。 关于Markdown，sublime是个好东西。 第二篇： 1.关于域名绑定，再次说明。血的教训告诉我们，Only需要添加两个解析。没有A记录，like this： 之后可以在此网站对你的博客进行测试，看看你的博客是否可以在国内解析到Coding，国外解析到Github。访问速度是否得到提升。 2.coding配置完成后，加载博客时会出现其广告界面，如果你想去掉呢，coding给出的解决办法是在网站底部加上codingpages官网链接或者加logo 个性化 终于到了万众瞩目的个性化步骤了，到这里，想必你已经根据博主推荐的链接成功搭建好了博客。 下面来具体说说个性化。 主题选择如果你按照上边搭建博客时推荐的文章那样，选择了next主题。那就不用多说。如果你觉得next主题不符合你的Style，可以参考这篇文章选择你喜欢的主题：Hexo博客主题推荐 但我还是推荐你用next主题，原因： next主题是github上最流行的主题，star和fork的数量远远超过了别的主题。所以相信群众的选择。 next主题的主题配置文件本就内置了许多插件，在个性化的过程中你只需要把flase改成true或者加上对应服务的id就可以直接使用。极为方便。这是其他很多主题没有做到的一点 next主题内部还分为4个主题方案：Muse、Mist、Pisces、Gemini，可以自由选择，更加多元化。 界面高端大气，配色低调奢华。 ps：如果你没有用next主题，那么以下个性化设置就不用看了。因为它们都是next的配置。 按照主题文档设置选定了主题后，建议先看看主题的文档进行个性化设置。里面是最基本的标签、分类设置，还有第三方服务设置：next主题配置 其他的个性化设置因为用的是next主题，所以这里也是针对于next主题的个性化配置。我博客的所有个性化都是来自这些链接： 网易云音乐链接设置，参考博客搭建时推荐的第一篇博客 这一篇看它的个性化设置部分：Hexo搭建博客教程 RSS和High特效 这篇真的厉害了，有30种特效：hexo的next主题个性化教程:打造炫酷网站 主讲第3方服务：配置第三方服务 这个也很方便，创建新文章后不用再去找了：Hexo添加文章时自动打开编辑器 创建一个菜单页面作为文章目录：hexo下新建页面下如何放多个文章 博客加密：加密插件Github，issue里有解决next主题兼容的方法 上边这些链接里的设置，均为博主亲测有效。从这些链接可以看出，博主也是折腾了很久的。。。 在Github上看issue或者提issue如果你还想折腾，还有两种途径： 可以看看next在Github上的issue：这些都是别人提的，可能会有你想要的设置。如果你遇到了问题，也可以自己提issue。这是网址：next/issues 去Hexo的官方插件页面找，这里的插件很多。只有你想不到，没有你找不到：Hexo插件 我的建议 个性化固然好，但是在设置的时候一定要细心，这些都是要打开代码文件去修改的，Sublime你值得拥有 关于图床，博主之前用的七牛云，但后来通知那些免费外链有效期过了，所以所有图片都没了。。。这里推荐SM.MS和PicGo 虽然个性化是可以让你的博客看起来高大上许多，但是不要太过了。忘了自己搭建博客的初心，只有文章才是最重要的。 强烈建议： 将博客源文件用github托管，可参考这篇回答 网站链接 下面是博客搭建过程中用到的一些平台和网站的链接，比如Livere提供的评论功能，七牛图床等： Hexo: https://hexo.io/ 阿里云: https://www.aliyun.com/ Livere: https://livere.com/ Leancloud: https://leancloud.cn/ 七牛: https://www.qiniu.com/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>学习小记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GithubPages</tag>
        <tag>CodingPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstBlog]]></title>
    <url>%2FFirstBlog%2F</url>
    <content type="text"><![CDATA[FistPage in my blog. the future is whitin reach. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[About Me- 97年小姐姐- ThoughtWorks.QA- 音乐 - 健身 - 美食 - 追剧- 巨蟹座 & 天生宅 & 懒癌晚期 & 重度拖延😂 About this site本博客基于Hexo博客框架搭建，并部署在GithubPages和CodingPages上。如果你也想搭建，可以参考我写的文章。 博客主要更新一些技术文章，一些旅行游记，还有一些闲言碎语和生活感悟😆 Join ThoughtWorks 以下链接为社招专用，校招可关注#ThoughtWorks校园招聘#公众号获取信息，也可给博主留言内推哟～ 软件测试–QA前端开发–FED document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
  </entry>
</search>
